/*************************************************************
 * Author:          Silverio Reyes
 * Filename:        DisplayCurrentTemp.java
 * Organization:    Oregon Institute of Technology
 * Class:           CST238 GUI
 *
 * Date Created:    7/01/18 - Mitch Besser-Laber Created .gitignore,
 *                            README.md, and REPORT.md files
 *
 * Date Modified:   7/24/18 - Created activity and
 *                            added dependencies
 *
 *                            Created Design layout
 *                            and implemented function for
 *                            displaying the current value
 *                            and incrementing the value.
 *                            Also changed text color when
 *                            the current value exceed the max
 *                            temperature setting.
 *
 *                  7/25/18 - Implemented method for alerting
 *                            the user when the current temp
 *                            has exceeded the max temperature
 *                            setting. The alert type vibrates
 *                            the users phone.
 *
 *                  7/25/18 - Implemented method for alerting
 *                            user via alert dialog.
 *
 *                  7/26/18 - Implemented method for alerting
 *                            user via notification alert
 *
 *                            Fixed stack issue so that
 *                            the activity is still on top of stack
 *                            running on pause and on resume
 *                            when the user leaves and goes back
 *                            or enters via notification message
 *
 *                            Created method for Ascending to
 *                            minimum temp set by user
 *
 *                  7/28/18 - Recommendation: Fix stack issue.
 *                            when user is on back press to
 *                            previous activity, ensure that
 *                            the current state (running process)
 *                            of this activity is destroyed.
 **************************************************************/
package reyes.silverio.targetalarmrange;

import android.Manifest;
import android.app.AlertDialog;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.content.res.ColorStateList;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.os.Build;
import android.os.CountDownTimer;
import android.os.Handler;
import android.os.SystemClock;
import android.os.VibrationEffect;
import android.os.Vibrator;
import android.support.v4.app.ActivityCompat;
import android.support.v4.app.NotificationCompat;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.telephony.SmsManager;
import android.telephony.TelephonyManager;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.Window;
import android.view.WindowManager;
import android.widget.TextView;
import android.widget.Toast;


import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Timer;
import java.util.TimerTask;

public class DisplayCurrentTemp extends AppCompatActivity {

    TextView tvCurrentTempValue;
    private String minTempValue;
    private String maxTempValue;
    private String degreeSymbol = "\u00B0"+"F";
    private boolean IsFahrenheit;
    private boolean vibrateCheck = true;
    private int meanTempVal;
    private ColorStateList defaultThemeColor;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_display_current_temp);

        InitializeVariables();
        AutoGeneratedTestCheck();
    }

    private void InitializeVariables() {

        // Get resources
        SharedPreferences preferences = this.getSharedPreferences("TemperatureSettingPreferences", Context.MODE_PRIVATE);
        minTempValue = preferences.getString("MinTempValue", null);
        maxTempValue = preferences.getString("MaxTempValue", null);
        IsFahrenheit = preferences.getBoolean("IsFahrenheit", true);

        // Initialize variables
        tvCurrentTempValue = (TextView)findViewById(R.id.TVCurrentTempValue);
        defaultThemeColor = tvCurrentTempValue.getTextColors();
    }

    private void AutoGeneratedTestCheck() {

        // Get the medium value and set degree symbol
        meanTempVal = (int)Math.ceil((Integer.parseInt(minTempValue) + Integer.parseInt(maxTempValue))/ 2.0);
        if(!IsFahrenheit){
            degreeSymbol = "\u00B0"+"C";
        }
        AscendToMaximumTempSettingTest(maxTempValue);
    }

    private void AscendToMaximumTempSettingTest(String maxTempValue) {

        // Set for string for max
        String msgTempMax = "max";

        // Display initial temp value
        tvCurrentTempValue.setText(String.valueOf(meanTempVal + degreeSymbol));

        // Get the delta between meanTempVal and MaxtempValue, add 11 to pass max, convert to milliseconds
        // Pass the value to timer and type of temp range (max)
        int DeltaCounterMaxMillisec = ((Integer.parseInt(maxTempValue) - meanTempVal) + 11) * 1000;
        PauseForTimerAscendingTemp(DeltaCounterMaxMillisec, msgTempMax);
    }

    private void DescendToMinimumTempSettingTest() {

        // Pause for 3000 ms before count down
        CountDownPause();

        // Set for string for max
        String msgTempMin = "min";

        // Get the delta between meanTempVal and MintempValue, add 11 to pass min, convert to milliseconds
        // Pass the value to timer
        int DeltaCounterMaxMillisec = ((meanTempVal - Integer.parseInt(minTempValue)) + 11) * 1000;
        PauseForTimerDescendingTemp(DeltaCounterMaxMillisec, msgTempMin);
    }

    private void PauseForTimerDescendingTemp(int millisec, final String tempRangeType) {
        CountDownTimer timer = new CountDownTimer(millisec,1000) {
            @Override
            public void onTick(long millisUntilFinished) {
                // Update the current temperature as it decreases
                meanTempVal -=1;
                tvCurrentTempValue.setText(String.valueOf(meanTempVal + degreeSymbol));

                if(meanTempVal == Integer.parseInt(maxTempValue))
                {
                    // Change text color to default setting indicating that the current value is =< the max value
                    tvCurrentTempValue.setTextColor(defaultThemeColor);
                }

                // Check if the current temp is less than the min temp setting
                if (meanTempVal < Integer.parseInt(minTempValue)){

                    // Only alert the user once the temp has exceeded the max temp setting
                    if(vibrateCheck){
                        // Send alert to user via text message and vibrate phone!
                        AlertUserViaPhoneVibrate();
                        AlertUserViaDialogBox(tempRangeType, tvCurrentTempValue.getText().toString(), (minTempValue + degreeSymbol));
                        //AlertUserViaTextMessage(tvCurrentTempValue.getText().toString(), (maxTempValue + degreeSymbol));
                        vibrateCheck = false;
                    }
                    // Change text color to red indicating that the current value exceeds the max value
                    tvCurrentTempValue.setTextColor(Color.RED);
                }
            }

            @Override
            public void onFinish() {
                //Toast.makeText(DisplayCurrentTemp.this, "CountDown Done!", Toast.LENGTH_SHORT).show();
                vibrateCheck = true;
            }
        }.start();
    }

    private void PauseForTimerAscendingTemp(int millisec, final String tempRangeType) {
        CountDownTimer timer = new CountDownTimer(millisec,1000) {
            @Override
            public void onTick(long millisUntilFinished) {
                // Update the current temperature as it increases
                meanTempVal +=1;
                tvCurrentTempValue.setText(String.valueOf(meanTempVal + degreeSymbol));

                // Check if the current temp is greater than the max temp setting
                if (meanTempVal > Integer.parseInt(maxTempValue)){

                    // Only alert the user once the temp has exceeded the max temp setting
                    if(vibrateCheck){
                        // Send alert to user via text message and vibrate phone!
                        AlertUserViaPhoneVibrate();
                        AlertUserViaDialogBox(tempRangeType, tvCurrentTempValue.getText().toString(), (maxTempValue + degreeSymbol));
                        //AlertUserViaTextMessage(tvCurrentTempValue.getText().toString(), (maxTempValue + degreeSymbol));
                        vibrateCheck = false;
                    }
                    // Change text color to red indicating that the current value exceeds the max value
                    tvCurrentTempValue.setTextColor(Color.RED);
                }
            }

            @Override
            public void onFinish() {
                //Toast.makeText(DisplayCurrentTemp.this, "CountDown Done!", Toast.LENGTH_SHORT).show();
                vibrateCheck = true;
                NotificationManager mNotificationManager =
                        (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
                mNotificationManager.cancelAll();
                DescendToMinimumTempSettingTest();
            }
        }.start();
    }

    private void AlertUserViaDialogBox(String tempRangeType, String currentTemp, String RangeSettingTemp) {

        // Get the current day of the week (Mon || Tues || .. || Sun)
        Calendar calender = Calendar.getInstance();
        Date date = calender.getTime();
        String day = new SimpleDateFormat("EE", Locale.ENGLISH).format(date.getTime());

        // Get system date and time. Then format it and store as string.
        Date dateTime = new Date();
        String dateTimeStyle = DateFormat.getDateTimeInstance().format(dateTime);
        String msg = "Temperature is now out of range from your " + tempRangeType + " set temperature of " +
                RangeSettingTemp + ". \n\nThis occurred on " + day + ", " + dateTimeStyle;

        AlertDialog.Builder builder;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            builder = new AlertDialog.Builder(this, android.R.style.Theme_Material_Dialog_Alert);
        } else {
            builder = new AlertDialog.Builder(this);
        }

        builder.setTitle("ALERT MESSAGE")
                .setMessage(msg)
                .setNegativeButton(android.R.string.ok, new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        // do nothing
                    }
                })
                .setIcon(android.R.drawable.ic_dialog_alert)
                .show();

        AlertUserViaNotification();
//        AlertDialog dialog = builder.create();
//        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
//        WindowManager.LayoutParams wmlp = dialog.getWindow().getAttributes();
//
//        wmlp.gravity = Gravity.CENTER | Gravity.LEFT;
//        wmlp.x = 100;   //x position
//        wmlp.y = 200;   //y position
//        dialog.setTitle("ALERT MESSAGE");
//        dialog.setMessage(msg);
//        dialog.setIcon(android.R.drawable.ic_dialog_alert);
//        dialog.getButton(dialog.BUTTON_NEGATIVE);
//        dialog.show();
    }

    private void AlertUserViaNotification() {
        // Instantiate a notification dialog and set some attributes
        Notification.Builder mBuilder =   new Notification.Builder(this)
                .setSmallIcon(R.drawable.alert_temp_icon)
                .setContentTitle("Set temperature out of range")
                .setContentText("Check current temperature")
                .setAutoCancel(true);

        // When user clicks on notification, send them to current activity state
        Intent intent = new Intent(this, DisplayCurrentTemp.class);;
        PendingIntent pi = PendingIntent.getActivity(this,0,intent,intent.getFlags());
        mBuilder.setContentIntent(pi);

        // Request system service
        NotificationManager mNotificationManager =
                (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        try{
            mNotificationManager.notify(0, mBuilder.build());
        }catch (Exception NotifyException){
            NotifyException.printStackTrace();
        }
    }

    // Work in progress: Not functional
    private void AlertUserViaTextMessage(String currentTemp, String RangeSettingTemp) {
        String msg = "ALERT: Current temperature " + currentTemp + " is now out of range from your set temperature of " + RangeSettingTemp + ".";
        String phoneNumber = "+15415392480";

        try {
            SmsManager smsManager = SmsManager.getDefault();
            //SmsManager.getDefault().sendTextMessage(phoneNumber, null, msgg,null,null);
            List<String> message = smsManager.divideMessage(msg);
            ArrayList<String> smsString = smsManager.divideMessage(msg);
            smsManager.sendMultipartTextMessage(phoneNumber, null, smsString, null, null);
            for (String m : message) {
                PendingIntent sentIntent = PendingIntent.getBroadcast(this, 0, new Intent("SMS_SENT"), 0);
                PendingIntent deliveredIntent = PendingIntent.getBroadcast(this, 0, new Intent("SMS_DELIVERED"), 0);
                //smsManager.sendTextMessage(phoneNumber, null, m, sentIntent, deliveredIntent);
                //smsManager.sendTextMessage(phoneNumber, null, msg, null, null);
                //smsManager.sendTextMessageWithoutPersisting(phoneNumber, null,msg,null,null);

            }
            //smsManager.sendTextMessage(phoneNumber, null, msgg, null, null);
        } catch (Exception TextException) {
            TextException.printStackTrace();
            android.util.Log.v("SMS ERROR", "Exception sending SMS [" + TextException.getMessage() + "]", TextException);
        }

        PendingIntent piSend = PendingIntent.getBroadcast(this, 0, new Intent("SMS_SENT"), 0);
        PendingIntent piDelivered = PendingIntent.getBroadcast(this, 0, new Intent("SMS_DELIVERED"), 0);

        byte[] data = new byte[msg.length()];

        for (int index = 0; index < msg.length() && index < 160; ++index) {
            data[index] = (byte) msg.charAt(index);
        }
        SmsManager smsManager = SmsManager.getDefault();
        Integer obj = new Integer(8091);
        short SMS_PORT = obj.shortValue();
        smsManager.sendDataMessage(phoneNumber, null, SMS_PORT, data, piSend, piDelivered);
    }

    private void AlertUserViaPhoneVibrate() {
        Vibrator vibrator = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);

        // Vibrate pattern {Delay, Vibrate, Sleep, Vibrate, Sleep, ...,}
        long[] pattern = {0, 1500, 1000, 1500, 1000, 1500};

        // API Level >= 26
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O){
            try{
                //vibrator.vibrate(VibrationEffect.createOneShot(3000, VibrationEffect.DEFAULT_AMPLITUDE));
                vibrator.vibrate(VibrationEffect.createWaveform(pattern, -1));
            }catch(Exception vibrateException){
                vibrateException.printStackTrace();
            }
        }
        // API Level < 26
        else{
            vibrator.vibrate(pattern, -1);
        }
    }

    private void CountDownPause(){
        Vibrator vibrator = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);

        // Vibrate pattern {Delay, Vibrate, Sleep, Vibrate, Sleep, ...,}
        long[] pattern = {0, 0, 1500, 0, 1500};
        vibrator.vibrate(pattern, -1);
    }

    /**********************************************************************
     * Purpose: This function handles the key event for pressing the back
     *          button when inside the main activity.
     *
     * Pre-condition: Back button not pressed. Stay in activity
     *
     * Post-condition: Back button is pressed. Exit application (Clear stack)
     ************************************************************************/
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event){
        if (keyCode == KeyEvent.KEYCODE_BACK){
//            Intent intent = new Intent(this, DisplayCurrentTemp.class);
//            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
//            startActivity(intent);

            //finish();
            // For now if user clicks back to main and idles on page, it will destroy entire stack
            // Need to figure out how to destroy stack. difficult
            finishActivity(1);
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
    }
}
